import { assert, raise } from "@m3o/errors";

const configs = {
  authUrl: "https://github.com/login/oauth",
  urls: {
    signIn: "/api/auth",
    logout: "/api/auth/logout",
    refresh: "/api/auth/refresh",
    callback: "/api/auth/callback",
  },
  credentials: {
    scope: "read:user user:email",
    client_id: Deno.env.get("GITHUB_CLIENT_ID") || "client_id",
    client_secret: Deno.env.get("GITHUB_CLIENT_SECRET") || "client_secret",
  },
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json",
  },
};

type Credentials = typeof configs["credentials"];

type AccessToken = {
  access_token: string;
  expires_in: number;
  refresh_token: string;
  refresh_token_expires_in: number;
  token_type: string;
  scope: string;
};

type AccessTokenError = {
  error: string;
  error_uri?: string;
  error_description?: string;
};

// TODO:
// - make a class to share configs
// - check for valid state

export function generateRedirectUrl(origin: string): string {
  const state = createState();
  const oAuthUrl = new URL(configs.authUrl + "/authorize");
  const redirectUri = `${origin}${configs.urls.callback}`;

  oAuthUrl.searchParams.append("client_id", configs.credentials.client_id);
  oAuthUrl.searchParams.append("scope", configs.credentials.scope);
  oAuthUrl.searchParams.append("redirect_uri", redirectUri);
  oAuthUrl.searchParams.append("response_type", "code");
  oAuthUrl.searchParams.append("state", state);

  const redirectUrl = oAuthUrl.toString().replaceAll("+", "%20");
  return redirectUrl;
}

type FetchAuthToken = Credentials & {
  code: string;
};

export async function fetchAuthToken(
  code: string,
  state: string,
): Promise<AccessToken> {
  assert(isValidState(state), "Invalid state");

  const accessTokenUrl = configs.authUrl + "/access_token";
  const body: FetchAuthToken = {
    ...configs.credentials,
    code,
  };

  const response = await fetch(accessTokenUrl, {
    method: "POST",
    headers: configs.headers,
    body: JSON.stringify(body),
  });
  const accessToken = await response.json();

  if (accessToken.error) {
    const error = accessToken as AccessTokenError;
    return raise(`fetch error: ${error.error}`);
  }

  return accessToken as AccessToken;
}

type RefreshAuthToken = Credentials & {
  refresh_token: string;
  grant_type: "refresh_token";
};

export async function refreshAuthToken(refreshToken: string) {
  assert(refreshToken.length > 0, "Invalid refresh token");

  const refreshTokenUrl = configs.authUrl + "/access_token";
  const body: RefreshAuthToken = {
    ...configs.credentials,
    refresh_token: refreshToken,
    grant_type: "refresh_token",
  };

  const response = await fetch(refreshTokenUrl, {
    method: "POST",
    headers: configs.headers,
    body: JSON.stringify(body),
  });
  const accessToken = await response.json();

  if (accessToken.error) {
    const error = accessToken as AccessTokenError;
    return raise(`fetch error: ${error.error}`);
  }

  return accessToken as AccessToken;
}

function createState(): string {
  // TODO: store state in a database
  return Math.random().toString(36).substring(7);
}

function isValidState(state: string): boolean {
  // TODO: check if state was generated by us
  return state.length > 0;
}
